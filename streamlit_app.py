# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yCiIr7WBCbeI6bwD6yxZLX3X05WAcifp
"""

!pip install category_encoders

"""# **Import Libraries and Data**"""

# Import Necessary Libraries
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from matplotlib.ticker import FuncFormatter
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LogisticRegression, LinearRegression, Ridge
from sklearn.metrics import accuracy_score, mean_absolute_error, mean_squared_error
from category_encoders import OneHotEncoder, OrdinalEncoder
from sklearn.pipeline import Pipeline, make_pipeline
from sklearn.impute import SimpleImputer
from sklearn.compose import make_column_transformer
from ipywidgets import Dropdown, FloatSlider, IntSlider, interact

# Read in data as dataframe
df = pd.read_csv('/content/nigeria_houses_data.csv')
df.head()

# Explore data
df.info()

# Descriptive statistics
df.describe()

# Rename title column
df = df.rename(columns={'title':'property_type'})

# Check for unique property types
df['property_type'].unique()

# Convert price column back to float
df["price"] = df["price"].apply(lambda x: float(x))
# Create a custom tick formatter to display prices in decimal notation
def price_formatter(x, pos):
    return f'{x:.2f}'

"""# **Exploratory Data Analysis**"""

# Check distribution of the prices of the properties
fig, ax = plt.subplots()
ax.hist(df['price'])
ax.xaxis.set_major_formatter(FuncFormatter(price_formatter))
plt.xlabel("Prices of Apartments(NGN)")
plt.ylabel("Frequency")
plt.xticks(rotation=90)

"""Based on the visualization presented, it's evident that our dataset contains a notable presence of outliers. These outliers can significantly impact the modeling process and the reliability of the results. To ensure the development of a robust and accurate model, it is advisable to consider outlier removal as an essential data preprocessing step. This procedure involves the identification and elimination of data points that deviate significantly from the norm, which can distort the model's predictive capabilities and overall performance. By addressing these outliers, we aim to enhance the quality and trustworthiness of the model's output."""

Q1 = df["price"].quantile(0.15)
Q3 = df["price"].quantile(0.85)
IQR = Q3 - Q1

# Define lower and upper bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
df = df[(df["price"] >= lower_bound) & (df["price"] <= upper_bound)]
df.head()

# Check distribution of the prices of the properties
fig, ax = plt.subplots()
ax.hist(df['price'])
ax.xaxis.set_major_formatter(FuncFormatter(price_formatter))
plt.xlabel("Prices of Apartments(NGN)")
plt.ylabel("Frequency")
plt.xticks(rotation=90)

# Visualize Comparison of Property Prices across Different States
fig, ax = plt.subplots()
ax.barh(df['state'], df['price'])
# Apply the custom price formatter to the y-axis
ax.xaxis.set_major_formatter(FuncFormatter(price_formatter))
plt.xlabel("Price (NGN)")
plt.ylabel("State")
plt.title("Comparison of Property Prices across Different States")
plt.xticks(rotation=45)

# Visualize Property Type vs Their Prices
fig, ax = plt.subplots()
ax.barh(df['property_type'], df['price'])
# Apply the custom price formatter to the y-axis
ax.xaxis.set_major_formatter(FuncFormatter(price_formatter))
plt.xlabel("Price of Property (NGN)")
plt.ylabel("Property Type")
plt.title("Property Type vs Their Prices")
plt.xticks(rotation=45)

# Visualize the Most Expensive Real Estate Towns in Nigeria
(
    (df.groupby("town")['price']
    .mean()/1e6)
    .sort_values(ascending=False)
    .head(20)
    .plot(kind="bar",
         xlabel = 'Towns',
         ylabel = "Prices [₦1M]",
         title = "Most Expensive Real Estate Towns in Nigeria")
);

# Checking the values in different states
values = df['state'].value_counts()
mask = values > 100
selected_states = values.index[mask]
df = df[df['state'].isin(selected_states)]

df['state'].value_counts()

# Visualize the Most Expensive Real Estate States in Nigeria
(
    (df.groupby("state")['price']
    .mean()/1e6)
    .sort_values(ascending=False)
    .head(10)
    .plot(kind="bar",
         xlabel = 'State',
         ylabel = "Prices [₦1M]",
         title = "Most Expensive Real Estate States in Nigeria")
);

# Visualize the Most Expensive Real Estate Towns in Nigeria
(
    (df.groupby("town")['price']
    .mean()/1e6)
    .sort_values(ascending=False)
    .head(20)
    .plot(kind="bar",
         xlabel = 'Towns',
         ylabel = "Prices [₦1M]",
         title = "Most Expensive Real Estate Towns in Nigeria")
);

# Visualize the Property types based on Prices in Nigeria
(
    (df.groupby("property_type")['price']
    .mean()/1e6)
    .sort_values()
    .head(20)
    .plot(kind="barh",
         xlabel = 'Property Type',
         ylabel = "Prices [₦1M]",
         title = "Property types based on Prices")
);

lagos_df = df[df['state'] == "Lagos"]
lagos_df.head()

(
    (lagos_df.groupby("town")['price']
    .mean()/1e6)
    .sort_values(ascending=False)
    .head(20)
    .plot(kind="bar",
         xlabel = 'Towns',
         ylabel = "Prices [₦1M]",
         title = "Most Expensive Real Estate Towns in Lagos")
);

# Remove suspected outliers
Q1 = lagos_df["price"].quantile(0.15)
Q3 = lagos_df["price"].quantile(0.85)
IQR = Q3 - Q1

# Define lower and upper bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
lagos_df = lagos_df[(lagos_df["price"] >= lower_bound) & (lagos_df["price"] <= upper_bound)]
lagos_df.reset_index(drop=True).head()

# Visualize the Property types based on Prices in Lagos
(
    (lagos_df.groupby("property_type")['price']
    .mean()/1e6)
    .sort_values()
    .head(10)
    .plot(kind="barh",
         xlabel = 'Property Type',
         ylabel = "Prices [₦1M]",
         title = "Property types based on Prices in Lagos")
);

values = lagos_df['town'].value_counts()
mask = values > 100
selected_towns = values.index[mask]
lagos_df = lagos_df[lagos_df['town'].isin(selected_towns)]
lagos_df = lagos_df.reset_index(drop=True)
lagos_df.head()

selected_towns

(
    (lagos_df.groupby("town")['price']
    .mean()/1e6)
    .sort_values(ascending=False)
    .head(10)
    .plot(kind="bar",
         xlabel = 'Towns',
         ylabel = "Prices [₦1M]",
         title = "Most Expensive Real Estate Towns in Lagos")
);

# Check for Multi-Colinearity
correlation = lagos_df.corr()
sns.heatmap(correlation)

correlation = lagos_df.corr()
correlation

"""# **Houses in Lekki Prediction Model**"""

df_lekki = lagos_df[lagos_df['town'] == "Lekki"]
df_lekki = df_lekki.reset_index(drop=True)
df_lekki.head()

(df_lekki.groupby("property_type")["price"].mean()/1e6).sort_values().plot(
          kind="barh",
           xlabel = "House Type",
           ylabel = "Prices [₦1M]",
           title = "Average Price by House Type in Lekki"
      );

# Remove suspected outliers
Q1 = df_lekki["price"].quantile(0.05)
Q3 = df_lekki["price"].quantile(0.95)
IQR = Q3 - Q1

# Define lower and upper bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
df_lekki = df_lekki[(df_lekki["price"] >= lower_bound) & (df_lekki["price"] <= upper_bound)]
df_lekki.reset_index(drop=True).head()

corr = df_lekki.corr()
sns.heatmap(corr)

"""# **Splitting the Data**"""

X = df_lekki.drop(columns=["parking_space","bathrooms","state","price","town"])
y = df_lekki["price"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Calculate baseline model
y_mean = y_train.mean()
y_pred_baseline = [y_mean] * len(y_train)
y_baseline_mae = mean_absolute_error(y_train, y_pred_baseline)
print("The mean is", y_mean)
print("The baseline Mean Absolute Error is", y_baseline_mae)

"""#**Training the Model**"""

# Train model
model = make_pipeline(
    OneHotEncoder(use_cat_names=True),
    LinearRegression()
)
model.fit(X_train, y_train)

"""# **Evaluating the Model**"""

y_pred_training = model.predict(X_train)
y_train_mae = mean_absolute_error(y_train, y_pred_training)
print("The Mean Absolute Error of the Training Data is", y_train_mae)

y_pred_test = model.predict(X_test)
y_test_mae = mean_absolute_error(y_test, y_pred_test)
print("The Mean Absolute Error of the Test Data is", y_test_mae)

test_result_data = pd.DataFrame({'test_price': y_test, 'prediction_price': y_pred_test})
test_result_data = test_result_data.reset_index(drop=True)
test_result_data.head()

test_result_data.head(20).plot(kind="bar")

# Calculate the mean squared error
mse = mean_squared_error(y_test, y_pred_test)

# Calculate the root mean squared error (RMSE)
rmse = np.sqrt(mse)

print(f"Root Mean Squared Error (RMSE): {rmse}")

"""# **Communicating the Result**"""

intercept = model.named_steps["linearregression"].intercept_
coefficients = model.named_steps["linearregression"].coef_
print("intercept:", intercept)
print(coefficients[:5])

feature_names = model.named_steps["onehotencoder"].get_feature_names()
print(feature_names)

feat_imp = pd.Series(coefficients, index=feature_names)
feat_imp.head()

feat_imp.sort_values().plot(kind="barh")
plt.xlabel("Importance [₦10M]")
plt.ylabel("Feature")
plt.title("Importance vs Features");

"""The barplot provided clearly illustrates the influence of the number of bedrooms on property prices, indicating that this particular feature holds the most substantial impact on pricing. Furthermore, it is worth noting that the housing type, specifically, being a Semi Detached Duplex, is associated with a significant reduction in property prices, reflecting a decrease of approximately 20 million naira. These observations underscore the importance of these factors in understanding the pricing dynamics within the real estate market.

# **Making Predictions**
"""

def make_prediction(bedrooms, toilets, property_type):
    data = {"bedrooms":bedrooms,
            "toilets":toilets,
            "property_type":property_type
    }
    df = pd.DataFrame(data, index=[0])
    prediction = model.predict(df).round(2)[0]
    return f"Predicted apartment price: ₦{prediction}"

make_prediction(4, 3, 'Terraced Bungalow')

interact(
    make_prediction,
    bedrooms=IntSlider(
        min=X_train["bedrooms"].min(),
        max=X_train["bedrooms"].max(),
        value=X_train["bedrooms"].mean(),
    ),
    toilets=IntSlider(
        min=X_train["toilets"].min(),
        max=X_train["toilets"].max(),
        step=1,
        value=X_train["toilets"].mean(),
    ),
    property_type=Dropdown(options=sorted(X_train["property_type"].unique())),
);

